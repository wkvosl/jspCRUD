https://mangkyu.tistory.com/132

[개발서적] 클린 코드(Clean Code) 핵심 요약 및 정리

[ 1. 객체의 생성에도 유의미한 이름을 사용하라 ]
객체의 생성자가 오버로딩 되는 경우 어떠한 값으로 어떻게 생성되는지 정보가 부족할 수 있다. 
그러므로 이러한 경우에는 정적 팩토리 메소드를 사용하는 것이 보다 명확한 코드를 작성하게 해 줄 것이다. 
하지만 구현을 드러내는 이름은 피하는 것이 좋다.

[ 2. 함수는 하나의 역할만 해야한다. ]
문제점 :
함수가 너무 길다. 새로운 직원 타입이 추가되면 더 길어질 것이다.
한 가지 작업만을 수행하지 않는다. 해딩 직원이 어느 타입인지 확인하고 있다.
SRP를 위반한다. 새로운 직원 타입이 추가되어도 임금을 계산하는 함수를 변경해야 한다.
OCP를 위반한다. 새로운 직원 타입이 추가되면 새로운 임금 계산 로직을 위하 코드를 변경해야 한다. 
유사한 함수가 계속 파생될 수 있다. 이러한 직원의 타입에 따른 코드는 다른 곳에 중첩될 수 있다.

해결:
이를 해결하기 위해서는 Employee를 추상클래스로 만들고, 직원 유형에 따른 하위 클래스를 선언하도록 하자. 
물론 하위 객체를 생성하기 위한 switch문은 불가피하다. 하지만 그래도 유사한 함수마다 분기해주는 것을 처리해줄 수 있으며, 
위의 문제점 중 상당수를 해결할 수 있을 것이다.

[ 3. 명령과 조회를 분리하라(Command와 Query의 분리) ]

[ 4. 오류코드 보다는 예외를 활용하자 ]
오류코드를 반환하면 그에 따른 분기가 일어나게 되고, 또 분기가 필요한 경우 중첩되기 마련이다.
이를 해결하기 위해 각각의 함수에서 예외를 발생시켜 잡는다면 코드를 더욱 간결하게 작성할 수 있다.
그리고 이렇게 처리하면 try-catch문이 생기게 되는데, 이 역시 분리하는 것이 코드를 이해하기 쉽게 도와줄 것이다. 

[ 5. 여러 예외가 발생하는 경우 Wrapper 클래스로 감싸자 ]  //이거 이해 못하겠음

[ 6. 테스트 코드의 작성 ]
요령:
1개의 테스트 함수에 대해 assert를 최소화하라
1개의 테스트 함수는 1가지 개념 만을 테스트하라

깨끗한 테스트 코드는 First라는 5가지 규칙:
Fast: 테스트는 빠르게 동작하여 자주 돌릴 수 있어야 한다.
Independent: 각각의 테스트는 독립적이며 서로 의존해서는 안된다.
Repeatable: 어느 환경에서도 반복 가능해야 한다.
Self-Validating: 테스트는 성공 또는 실패로 bool 값으로 결과를 내어 자체적으로 검증되어야 한다.
Timely: 테스트는 적시에 즉, 테스트하려는 실제 코드를 구현하기 직전에 구현해야 한다.

[ 7. 클래스의 최소화 ]
 단일 책임 원칙에 따라 1가지 책임만을 가져야 한다. 
 
[ 8. 클래스의 응집도 ]
 응집도란 클래스의 메소드와 변수가 얼마나 의존하여 사용되는지를 의미
 
[ 9. 변경하기 쉬운 클래스 ]
요구사항은 수시로 변하기 때문에, 변경하기 쉬운 클래스를 만드는 것이 중요하다. 
변경하기 쉬운 클래스는 기본적으로 단일 책임 원칙을 지켜야 한다. 또한 구현체 보다는 추상체에 의존하여야 한다. 
그리고 결국 핵심은 다형성이다.

[ 10. 설계 품질을 높여주는 4가지 규칙 ]   : 2~4는 리팩토링 과정에 해당한다.
모든 테스트를 실행하라: 테스트가 쉬운 코드를 작성하다 보면 SRP를 준수하고, 더 낮은 결합도를 갖는 설계를 얻을 수 있다.
중복을 제거하라: 깔끔한 시스템을 만들기 위해 단 몇 줄이라도 중복을 제거해야 한다.
프로그래머의 의도를 표현하라: 좋은 이름, 작은 클래스와 메소드의 크기, 표준 명칭, 단위 테스트 작성 등을 통해 이를 달성할 수 있다.
클래스와 메소드의 수를 최소로 줄여라: 클래스와 메소드를 작게 유지함으로써 시스템 크기 역시 작게 유지할 수 있다.
	2~4의 작업은 모든 테스트케이스를 작성한 후에 코드와 클래스를 정리하기 때문에 안전하다.

[ 11. 변경하기 쉬운 클래스 ]
반복적인 정리 끝에 나온 코드라고 한다. 
결국 좋은 코드를 만들기 위해서는 많은 시간과 노력이 필요한 것

[ 12. 디미터 법칙 ]
디미터의 법칙은 어떤 모듈이 호출하는 객체의 속사정을 몰라야 한다는 것이다. 
그렇기에 객체는 자료를 숨기고 함수를 공개해야 한다. 
만약 자료를 그대로 노출하면 내부 구조가 드러나 결합도가 높아지게 된다.

final String outputDir = FileManager.getInstance().getOptions().getModule().getAbsolutePath();

아래와 같이 나누는 것이 좋다.
Options options = ctxt.getOptions();
File scratchDir = opts.getScratchDir();
final String outputDir = scratchDir.getAbsolutePath();

데이터가 아닌 객체를 참고할 때 여러 번의 .을 사용하는 경우, 객체에게 메세지를 보내도록 변경하자.

